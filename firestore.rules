rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ─── Usage & plan helpers ───────────────────────────────────────────────

    // Returns true if the client is trying to change the plan field.
    // plan can only be set via Admin SDK (server-side); clients may not touch it.
    function planUnchanged() {
      let oldPlan = resource.data.get('plan', 'free');
      let newPlan = request.resource.data.get('plan', 'free');
      return newPlan == oldPlan;
    }

    // On document creation, plan must be 'free' (or absent).
    // Paid plans can only be granted server-side via Admin SDK.
    function planIsValidOnCreate() {
      let p = request.resource.data.get('plan', 'free');
      return p == 'free';
    }

    // Returns true if the usage update is either:
    //   (a) a legitimate period reset (periodStart advances + all counters reset to 0), or
    //   (b) a counter increment within the same period (counters can only go up).
    // This prevents clients from manually zeroing counters to bypass limits.
    function usageUpdateValid() {
      let touchingUsage = 'usage' in request.resource.data;
      let hasOldUsage   = 'usage' in resource.data;
      let newU      = request.resource.data.get('usage', {});
      let oldU      = resource.data.get('usage', {});
      let oldStart  = oldU.get('periodStart', '');
      let newStart  = newU.get('periodStart', '');
      return !touchingUsage
          || !hasOldUsage
          || (newStart > oldStart
                ? (newU.get('messages', 0)     == 0
                && newU.get('reanalyzes', 0)   == 0
                && newU.get('projectChats', 0) == 0)
                : (newStart == oldStart
                && newU.get('messages', 0)     >= oldU.get('messages', 0)
                && newU.get('reanalyzes', 0)   >= oldU.get('reanalyzes', 0)
                && newU.get('projectChats', 0) >= oldU.get('projectChats', 0)));
    }

    // ─── User profiles ──────────────────────────────────────────────────────
    match /users/{userId} {
      // Read: own doc only
      allow read: if request.auth != null && request.auth.uid == userId;

      // Create: own doc only, and plan must be 'free' (or absent).
      // Paid plans are granted server-side only.
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && planIsValidOnCreate();

      // Update: own doc, but plan cannot be changed client-side and usage
      //         counters may only increase (or reset when period advances).
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && planUnchanged()
                    && usageUpdateValid();

      // Delete: own doc only — used by the account-deletion flow.
      // Subcollections (chats, savedProjects, results) inherit their own write rules.
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Chat history
      match /chats/{chatId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Saved projects and project chats
      match /savedProjects/{projectId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Saved analysis results
      match /results/{resultId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Persistent agent state and memory
      match /agent/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Analysis results
    match /analyses/{analysisId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }
  }
}
